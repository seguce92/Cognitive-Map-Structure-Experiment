<!DOCTYPE html>
<html>
<head>
  <title>Spatial Memory Experiment</title>
  <script src="jquery-1.7.2.min.js"></script>
  
    <script src="three.min.js"></script>
    <script src="SkyShader.js"></script>
  
  <!--<script src="numeric-1.2.6.min.js"></script>-->
</head>
<body>
	
<script>


			var container, stats;

			var camera, controls, scene, renderer;

			var sky, sunSphere;

			function initSky(){

				// Add Sky Mesh
				sky = new THREE.Sky();
				scene.add( sky.mesh );


				// Add Sun Helper
				sunSphere = new THREE.Mesh( new THREE.SphereGeometry( 20000, 30, 30 ),
					new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: false }));
				sunSphere.position.y = -700000;
				sunSphere.visible = true;
				scene.add( sunSphere );

				/// GUI

				var effectController  = {
					turbidity: 10,
					reileigh: 2,
					mieCoefficient: 0.005,
					mieDirectionalG: 0.8,
					luminance: 1,
					inclination: 0.49, // elevation / inclination
					azimuth: 0.25, // Facing front,					
					sun: !true
				};

				var distance = 400000;

				function guiChanged() {
					var uniforms = sky.uniforms;
					uniforms.turbidity.value = effectController.turbidity;
					uniforms.reileigh.value = effectController.reileigh;
					uniforms.luminance.value = effectController.luminance;
					uniforms.mieCoefficient.value = effectController.mieCoefficient;
					uniforms.mieDirectionalG.value = effectController.mieDirectionalG;

					var theta = Math.PI * (effectController.inclination - 0.5);
					var phi = 2 * Math.PI * (effectController.azimuth - 0.5);

					sunSphere.position.x = distance * Math.cos(phi);
					sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta); 
					sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta); 

					sunSphere.visible = effectController.sun;

					sky.uniforms.sunPosition.value.copy(sunSphere.position);

				}
				
				guiChanged();


				camera.lookAt(sunSphere.position);
			}
			
			init();
			animate();


			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.5, 2000000 );
				camera.position.z = 2000;

				camera.position.y = 100;
				camera.setLens(20);

				scene = new THREE.Scene();

				var size = 500;

				var geometryLines = new THREE.BoxGeometry( size, size, size );
	
				var geometryPlane = new THREE.PlaneGeometry( size * 10, size * 10, 1, 1);
				geometryPlane.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
	

				var materialLines = new THREE.MeshBasicMaterial( { wireframe: true } );

				meshLines = new THREE.Mesh( geometryLines, materialLines );

				// scene.add( meshLines );

				scene.add( new THREE.Mesh( geometryPlane, materialLines ) );

				initSky();

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setSize( window.innerWidth, window.innerHeight );

				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );


			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			var time = 0;

			function animate() {

				time = Date.now();

				requestAnimationFrame( animate );
				
				render();

			}

			function render() {

				renderer.render( scene, camera );
				stats.update();

			}

</script>
	
	
	<!--
	<script>

function sigmoid(x) {
    return 1.0 / (1.0 + Math.exp(-x));

};

function gradientDescent(theta, gradient, alpha) {
    return numeric.sub(theta, numeric.mul(gradient(theta), alpha));
}

var alpha = 0.0001, lambda = 0;
// Initialize theta to zero-vector
var theta = numeric.rep([3, 1], 0);

// X is feature matrix, y is group vector
var X = [], y = [];

// Gradient function for logistic regression
var gradient = function(theta) {
    var H = numeric.dot(X, theta);
    for (var i = 0; i < H.length; i++) {
        for (var j = 0; j < H[i].length; j++) {
            H[i][j] = sigmoid(H[i][j]);
        }
    }
    var regularization = numeric.mul(theta, lambda / X.length);
    regularization[0][0] = 0.0;
    var grad = numeric.dot(numeric.transpose(X), numeric.sub(H, y));
    grad = numeric.div(grad, X.length);
    return numeric.add(grad, regularization);
    //return grad;
};

//
//X=[[1,1,1],[2,2,2],[3,3,3],[1,1,4],[2,2,5],[3,3,6]];
//y=[[0],[0],[0],[1],[1],[1]];
X = [[82.8743,0,59.0779],[56.4458,100,49.81],[51.5163,0,84.3632],[69.1019,100,62.344],[17.6944,0,84.2404],[76.2405,0,69.1622],[16.2657,0,4.1852],[66.615,100,34.4728],[90.5283,0,91.0464],[69.1104,0,51.2347],[33.6112,100,75.0505],[63.2833,0,57.65],[61.5848,0,83.8271],[10.8846,0,29.701],[52.8414,0,82.7956]];
y = [[0],[0],[1],[1],[0],[1],[1],[0],[1],[1],[1],[1],[1],[0],[1]];
//

if (X.length) {
    for (var i = 0; i < 20000; i++) {
        theta = gradientDescent(theta, gradient, alpha);
    }
}
alert(theta);
	
	</script>
	-->
</body>
</html>